//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
  providedIn: 'root',
})
export class IdentityClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @return OK
   */
  register(body: RegisterRequest): Observable<void> {
    let url_ = this.baseUrl + '/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = HttpValidationProblemDetails.fromJS(resultData400);
          return throwException(
            'Bad Request',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param useCookies (optional)
   * @param useSessionCookies (optional)
   * @return OK
   */
  login(
    body: LoginRequest,
    useCookies?: boolean | undefined,
    useSessionCookies?: boolean | undefined
  ): Observable<AccessTokenResponse> {
    let url_ = this.baseUrl + '/login?';
    if (useCookies === null)
      throw new Error("The parameter 'useCookies' cannot be null.");
    else if (useCookies !== undefined)
      url_ += 'useCookies=' + encodeURIComponent('' + useCookies) + '&';
    if (useSessionCookies === null)
      throw new Error("The parameter 'useSessionCookies' cannot be null.");
    else if (useSessionCookies !== undefined)
      url_ +=
        'useSessionCookies=' + encodeURIComponent('' + useSessionCookies) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<AccessTokenResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<AccessTokenResponse>;
        })
      );
  }

  protected processLogin(
    response: HttpResponseBase
  ): Observable<AccessTokenResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccessTokenResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  refresh(body: RefreshRequest): Observable<AccessTokenResponse> {
    let url_ = this.baseUrl + '/refresh';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefresh(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefresh(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<AccessTokenResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<AccessTokenResponse>;
        })
      );
  }

  protected processRefresh(
    response: HttpResponseBase
  ): Observable<AccessTokenResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccessTokenResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param changedEmail (optional)
   * @return OK
   */
  mapIdentityApi_confirmEmail(
    userId: string,
    code: string,
    changedEmail?: string | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/confirmEmail?';
    if (userId === undefined || userId === null)
      throw new Error(
        "The parameter 'userId' must be defined and cannot be null."
      );
    else url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
    if (code === undefined || code === null)
      throw new Error(
        "The parameter 'code' must be defined and cannot be null."
      );
    else url_ += 'code=' + encodeURIComponent('' + code) + '&';
    if (changedEmail === null)
      throw new Error("The parameter 'changedEmail' cannot be null.");
    else if (changedEmail !== undefined)
      url_ += 'changedEmail=' + encodeURIComponent('' + changedEmail) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMapIdentityApi_confirmEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMapIdentityApi_confirmEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processMapIdentityApi_confirmEmail(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  resendConfirmationEmail(
    body: ResendConfirmationEmailRequest
  ): Observable<void> {
    let url_ = this.baseUrl + '/resendConfirmationEmail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResendConfirmationEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResendConfirmationEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResendConfirmationEmail(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  forgotPassword(body: ForgotPasswordRequest): Observable<void> {
    let url_ = this.baseUrl + '/forgotPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processForgotPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processForgotPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processForgotPassword(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = HttpValidationProblemDetails.fromJS(resultData400);
          return throwException(
            'Bad Request',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  resetPassword(body: ResetPasswordRequest): Observable<void> {
    let url_ = this.baseUrl + '/resetPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = HttpValidationProblemDetails.fromJS(resultData400);
          return throwException(
            'Bad Request',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  TwoFa(body: TwoFactorRequest): Observable<TwoFactorResponse> {
    let url_ = this.baseUrl + '/manage/2fa';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.process2fa(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.process2fa(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<TwoFactorResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TwoFactorResponse>;
        })
      );
  }

  protected process2fa(
    response: HttpResponseBase
  ): Observable<TwoFactorResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TwoFactorResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = HttpValidationProblemDetails.fromJS(resultData400);
          return throwException(
            'Bad Request',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Not Found', status, _responseText, _headers);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  infoGET(): Observable<InfoResponse> {
    let url_ = this.baseUrl + '/manage/info';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInfoGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInfoGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<InfoResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<InfoResponse>;
        })
      );
  }

  protected processInfoGET(
    response: HttpResponseBase
  ): Observable<InfoResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = InfoResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = HttpValidationProblemDetails.fromJS(resultData400);
          return throwException(
            'Bad Request',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Not Found', status, _responseText, _headers);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  infoPOST(body: InfoRequest): Observable<InfoResponse> {
    let url_ = this.baseUrl + '/manage/info';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInfoPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInfoPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<InfoResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<InfoResponse>;
        })
      );
  }

  protected processInfoPOST(
    response: HttpResponseBase
  ): Observable<InfoResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = InfoResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = HttpValidationProblemDetails.fromJS(resultData400);
          return throwException(
            'Bad Request',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Not Found', status, _responseText, _headers);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class HouseClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @return OK
   */
  housesGET(houseId: number): Observable<HouseModel> {
    let url_ = this.baseUrl + '/api/houses/{houseId}';
    if (houseId === undefined || houseId === null)
      throw new Error("The parameter 'houseId' must be defined.");
    url_ = url_.replace('{houseId}', encodeURIComponent('' + houseId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousesGET(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousesGET(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HouseModel>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HouseModel>;
        })
      );
  }

  protected processHousesGET(
    response: HttpResponseBase
  ): Observable<HouseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HouseModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  housesPUT(houseId: number, body: HouseModel): Observable<void> {
    let url_ = this.baseUrl + '/api/houses/{houseId}';
    if (houseId === undefined || houseId === null)
      throw new Error("The parameter 'houseId' must be defined.");
    url_ = url_.replace('{houseId}', encodeURIComponent('' + houseId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousesPUT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousesPUT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processHousesPUT(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  housesAll(): Observable<HouseViewModel[]> {
    let url_ = this.baseUrl + '/api/houses';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousesAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousesAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HouseViewModel[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              HouseViewModel[]
            >;
        })
      );
  }

  protected processHousesAll(
    response: HttpResponseBase
  ): Observable<HouseViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(HouseViewModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  housesPOST(body: HouseModel): Observable<number> {
    let url_ = this.baseUrl + '/api/houses';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousesPOST(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousesPOST(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processHousesPOST(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  housesAll2(tenantId: string): Observable<HouseViewModel[]> {
    let url_ = this.baseUrl + '/api/houses/{tenantId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousesAll2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousesAll2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HouseViewModel[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              HouseViewModel[]
            >;
        })
      );
  }

  protected processHousesAll2(
    response: HttpResponseBase
  ): Observable<HouseViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(HouseViewModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ParkedCarClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @return OK
   */
  parkedCars(body: ParkedCarModel): Observable<number> {
    let url_ = this.baseUrl + '/api/parkedCars';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processParkedCars(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processParkedCars(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processParkedCars(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  search(body: ParkedCarSearchModel): Observable<ParkedCarViewModel[]> {
    let url_ = this.baseUrl + '/api/parkedCars/search';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearch(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ParkedCarViewModel[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ParkedCarViewModel[]
            >;
        })
      );
  }

  protected processSearch(
    response: HttpResponseBase
  ): Observable<ParkedCarViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ParkedCarViewModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'Unauthorized',
            status,
            _responseText,
            _headers
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException('Forbidden', status, _responseText, _headers);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export class AccessTokenResponse implements IAccessTokenResponse {
  readonly tokenType?: string | undefined;
  accessToken!: string | undefined;
  expiresIn!: number;
  refreshToken!: string | undefined;

  constructor(data?: IAccessTokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).tokenType = _data['tokenType'];
      this.accessToken = _data['accessToken'];
      this.expiresIn = _data['expiresIn'];
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): AccessTokenResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AccessTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tokenType'] = this.tokenType;
    data['accessToken'] = this.accessToken;
    data['expiresIn'] = this.expiresIn;
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IAccessTokenResponse {
  tokenType?: string | undefined;
  accessToken: string | undefined;
  expiresIn: number;
  refreshToken: string | undefined;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
  email!: string | undefined;

  constructor(data?: IForgotPasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ForgotPasswordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ForgotPasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IForgotPasswordRequest {
  email: string | undefined;
}

export class HouseModel implements IHouseModel {
  houseId?: number;
  street!: string;
  number!: string;
  zip!: number;
  city!: string;

  constructor(data?: IHouseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.houseId = _data['houseId'];
      this.street = _data['street'];
      this.number = _data['number'];
      this.zip = _data['zip'];
      this.city = _data['city'];
    }
  }

  static fromJS(data: any): HouseModel {
    data = typeof data === 'object' ? data : {};
    let result = new HouseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['houseId'] = this.houseId;
    data['street'] = this.street;
    data['number'] = this.number;
    data['zip'] = this.zip;
    data['city'] = this.city;
    return data;
  }
}

export interface IHouseModel {
  houseId?: number;
  street: string;
  number: string;
  zip: number;
  city: string;
}

export class HouseViewModel implements IHouseViewModel {
  houseId?: number;
  street?: string | undefined;
  number?: string | undefined;

  constructor(data?: IHouseViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.houseId = _data['houseId'];
      this.street = _data['street'];
      this.number = _data['number'];
    }
  }

  static fromJS(data: any): HouseViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new HouseViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['houseId'] = this.houseId;
    data['street'] = this.street;
    data['number'] = this.number;
    return data;
  }
}

export interface IHouseViewModel {
  houseId?: number;
  street?: string | undefined;
  number?: string | undefined;
}

export class HttpValidationProblemDetails
  implements IHttpValidationProblemDetails
{
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  errors?: { [key: string]: string[] } | undefined;

  [key: string]: any;

  constructor(data?: IHttpValidationProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): HttpValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new HttpValidationProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data['errors'])[key] = (<any>this.errors)[key];
      }
    }
    return data;
  }
}

export interface IHttpValidationProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  errors?: { [key: string]: string[] } | undefined;

  [key: string]: any;
}

export class InfoRequest implements IInfoRequest {
  newEmail?: string | undefined;
  newPassword?: string | undefined;
  oldPassword?: string | undefined;

  constructor(data?: IInfoRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.newEmail = _data['newEmail'];
      this.newPassword = _data['newPassword'];
      this.oldPassword = _data['oldPassword'];
    }
  }

  static fromJS(data: any): InfoRequest {
    data = typeof data === 'object' ? data : {};
    let result = new InfoRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['newEmail'] = this.newEmail;
    data['newPassword'] = this.newPassword;
    data['oldPassword'] = this.oldPassword;
    return data;
  }
}

export interface IInfoRequest {
  newEmail?: string | undefined;
  newPassword?: string | undefined;
  oldPassword?: string | undefined;
}

export class InfoResponse implements IInfoResponse {
  email!: string | undefined;
  isEmailConfirmed!: boolean;

  constructor(data?: IInfoResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.isEmailConfirmed = _data['isEmailConfirmed'];
    }
  }

  static fromJS(data: any): InfoResponse {
    data = typeof data === 'object' ? data : {};
    let result = new InfoResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['isEmailConfirmed'] = this.isEmailConfirmed;
    return data;
  }
}

export interface IInfoResponse {
  email: string | undefined;
  isEmailConfirmed: boolean;
}

export class LoginRequest implements ILoginRequest {
  email!: string | undefined;
  password!: string | undefined;
  twoFactorCode?: string | undefined;
  twoFactorRecoveryCode?: string | undefined;

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
      this.twoFactorCode = _data['twoFactorCode'];
      this.twoFactorRecoveryCode = _data['twoFactorRecoveryCode'];
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new LoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    data['twoFactorCode'] = this.twoFactorCode;
    data['twoFactorRecoveryCode'] = this.twoFactorRecoveryCode;
    return data;
  }
}

export interface ILoginRequest {
  email: string | undefined;
  password: string | undefined;
  twoFactorCode?: string | undefined;
  twoFactorRecoveryCode?: string | undefined;
}

export class ParkedCarModel implements IParkedCarModel {
  parkedCarId?: number;
  firstname!: string;
  lastname!: string;
  carBrand!: string;
  numberPlate!: string;
  arrival!: Date;
  timeZoneInfo!: string;
  houseId!: number;

  constructor(data?: IParkedCarModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parkedCarId = _data['parkedCarId'];
      this.firstname = _data['firstname'];
      this.lastname = _data['lastname'];
      this.carBrand = _data['carBrand'];
      this.numberPlate = _data['numberPlate'];
      this.arrival = _data['arrival']
        ? new Date(_data['arrival'].toString())
        : <any>undefined;
      this.timeZoneInfo = _data['timeZoneInfo'];
      this.houseId = _data['houseId'];
    }
  }

  static fromJS(data: any): ParkedCarModel {
    data = typeof data === 'object' ? data : {};
    let result = new ParkedCarModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parkedCarId'] = this.parkedCarId;
    data['firstname'] = this.firstname;
    data['lastname'] = this.lastname;
    data['carBrand'] = this.carBrand;
    data['numberPlate'] = this.numberPlate;
    data['arrival'] = this.arrival
      ? this.arrival.toISOString()
      : <any>undefined;
    data['timeZoneInfo'] = this.timeZoneInfo;
    data['houseId'] = this.houseId;
    return data;
  }
}

export interface IParkedCarModel {
  parkedCarId?: number;
  firstname: string;
  lastname: string;
  carBrand: string;
  numberPlate: string;
  arrival: Date;
  timeZoneInfo: string;
  houseId: number;
}

export class ParkedCarSearchModel implements IParkedCarSearchModel {
  dateFrom?: Date;
  dateTo?: Date;
  houseIds!: number[] | undefined;

  constructor(data?: IParkedCarSearchModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dateFrom = _data['dateFrom']
        ? new Date(_data['dateFrom'].toString())
        : <any>undefined;
      this.dateTo = _data['dateTo']
        ? new Date(_data['dateTo'].toString())
        : <any>undefined;
      if (Array.isArray(_data['houseIds'])) {
        this.houseIds = [] as any;
        for (let item of _data['houseIds']) this.houseIds!.push(item);
      }
    }
  }

  static fromJS(data: any): ParkedCarSearchModel {
    data = typeof data === 'object' ? data : {};
    let result = new ParkedCarSearchModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dateFrom'] = this.dateFrom
      ? formatDate(this.dateFrom)
      : <any>undefined;
    data['dateTo'] = this.dateTo ? formatDate(this.dateTo) : <any>undefined;
    if (Array.isArray(this.houseIds)) {
      data['houseIds'] = [];
      for (let item of this.houseIds) data['houseIds'].push(item);
    }
    return data;
  }
}

export interface IParkedCarSearchModel {
  dateFrom?: Date;
  dateTo?: Date;
  houseIds: number[] | undefined;
}

export class ParkedCarViewModel implements IParkedCarViewModel {
  parkedCarId?: number;
  firstname?: string | undefined;
  lastname?: string | undefined;
  carBrand?: string | undefined;
  numberPlate?: string | undefined;
  arrival?: Date;
  houseAdress?: string | undefined;
  houseNumber?: string | undefined;
  zip?: number;

  constructor(data?: IParkedCarViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parkedCarId = _data['parkedCarId'];
      this.firstname = _data['firstname'];
      this.lastname = _data['lastname'];
      this.carBrand = _data['carBrand'];
      this.numberPlate = _data['numberPlate'];
      this.arrival = _data['arrival']
        ? new Date(_data['arrival'].toString())
        : <any>undefined;
      this.houseAdress = _data['houseAdress'];
      this.houseNumber = _data['houseNumber'];
      this.zip = _data['zip'];
    }
  }

  static fromJS(data: any): ParkedCarViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new ParkedCarViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parkedCarId'] = this.parkedCarId;
    data['firstname'] = this.firstname;
    data['lastname'] = this.lastname;
    data['carBrand'] = this.carBrand;
    data['numberPlate'] = this.numberPlate;
    data['arrival'] = this.arrival
      ? this.arrival.toISOString()
      : <any>undefined;
    data['houseAdress'] = this.houseAdress;
    data['houseNumber'] = this.houseNumber;
    data['zip'] = this.zip;
    return data;
  }
}

export interface IParkedCarViewModel {
  parkedCarId?: number;
  firstname?: string | undefined;
  lastname?: string | undefined;
  carBrand?: string | undefined;
  numberPlate?: string | undefined;
  arrival?: Date;
  houseAdress?: string | undefined;
  houseNumber?: string | undefined;
  zip?: number;
}

export class RefreshRequest implements IRefreshRequest {
  refreshToken!: string | undefined;

  constructor(data?: IRefreshRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): RefreshRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IRefreshRequest {
  refreshToken: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
  email!: string | undefined;
  password!: string | undefined;

  constructor(data?: IRegisterRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): RegisterRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface IRegisterRequest {
  email: string | undefined;
  password: string | undefined;
}

export class ResendConfirmationEmailRequest
  implements IResendConfirmationEmailRequest
{
  email!: string | undefined;

  constructor(data?: IResendConfirmationEmailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ResendConfirmationEmailRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ResendConfirmationEmailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IResendConfirmationEmailRequest {
  email: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
  email!: string | undefined;
  resetCode!: string | undefined;
  newPassword!: string | undefined;

  constructor(data?: IResetPasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.resetCode = _data['resetCode'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ResetPasswordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['resetCode'] = this.resetCode;
    data['newPassword'] = this.newPassword;
    return data;
  }
}

export interface IResetPasswordRequest {
  email: string | undefined;
  resetCode: string | undefined;
  newPassword: string | undefined;
}

export class TwoFactorRequest implements ITwoFactorRequest {
  enable?: boolean | undefined;
  twoFactorCode?: string | undefined;
  resetSharedKey?: boolean;
  resetRecoveryCodes?: boolean;
  forgetMachine?: boolean;

  constructor(data?: ITwoFactorRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.enable = _data['enable'];
      this.twoFactorCode = _data['twoFactorCode'];
      this.resetSharedKey = _data['resetSharedKey'];
      this.resetRecoveryCodes = _data['resetRecoveryCodes'];
      this.forgetMachine = _data['forgetMachine'];
    }
  }

  static fromJS(data: any): TwoFactorRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TwoFactorRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['enable'] = this.enable;
    data['twoFactorCode'] = this.twoFactorCode;
    data['resetSharedKey'] = this.resetSharedKey;
    data['resetRecoveryCodes'] = this.resetRecoveryCodes;
    data['forgetMachine'] = this.forgetMachine;
    return data;
  }
}

export interface ITwoFactorRequest {
  enable?: boolean | undefined;
  twoFactorCode?: string | undefined;
  resetSharedKey?: boolean;
  resetRecoveryCodes?: boolean;
  forgetMachine?: boolean;
}

export class TwoFactorResponse implements ITwoFactorResponse {
  sharedKey!: string | undefined;
  recoveryCodesLeft!: number;
  recoveryCodes?: string[] | undefined;
  isTwoFactorEnabled!: boolean;
  isMachineRemembered!: boolean;

  constructor(data?: ITwoFactorResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sharedKey = _data['sharedKey'];
      this.recoveryCodesLeft = _data['recoveryCodesLeft'];
      if (Array.isArray(_data['recoveryCodes'])) {
        this.recoveryCodes = [] as any;
        for (let item of _data['recoveryCodes']) this.recoveryCodes!.push(item);
      }
      this.isTwoFactorEnabled = _data['isTwoFactorEnabled'];
      this.isMachineRemembered = _data['isMachineRemembered'];
    }
  }

  static fromJS(data: any): TwoFactorResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TwoFactorResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sharedKey'] = this.sharedKey;
    data['recoveryCodesLeft'] = this.recoveryCodesLeft;
    if (Array.isArray(this.recoveryCodes)) {
      data['recoveryCodes'] = [];
      for (let item of this.recoveryCodes) data['recoveryCodes'].push(item);
    }
    data['isTwoFactorEnabled'] = this.isTwoFactorEnabled;
    data['isMachineRemembered'] = this.isMachineRemembered;
    return data;
  }
}

export interface ITwoFactorResponse {
  sharedKey: string | undefined;
  recoveryCodesLeft: number;
  recoveryCodes?: string[] | undefined;
  isTwoFactorEnabled: boolean;
  isMachineRemembered: boolean;
}

function formatDate(d: Date) {
  return (
    d.getFullYear() +
    '-' +
    (d.getMonth() < 9 ? '0' + (d.getMonth() + 1) : d.getMonth() + 1) +
    '-' +
    (d.getDate() < 10 ? '0' + d.getDate() : d.getDate())
  );
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
